[[код для создания полигона]]

Как мы рассматривали ранее буферы и иные виды хранения\отправки\обработки данных ([[примеры вычислений на RV]]), таким же образом мы можем взаимодействовать с видеокартой не как с вычислителем, а как с графическим инструментом. Для этого надо перевести вычислитель в "графический режим". Это условное обозначение, которое имеет меньше свободы, нежели в предыдущих режимах исчисления, но значительно упрощает работу с графикой.

И так, для запуска графических операций нам необходимо пройти следующие этапы:
1. Объявить объект граф. конвейера, он описывает поведение графического конвейера, так же, как раньше бы объявляли вычислительный конвейер.
2. Буфер(ы) для содержания объектов рисования
3. `framebuffer` - объект с набором изображений для записи
4. Дескрипторы и константы

Как процессор представляет себе работу в графическом режиме? Это что-то типа нескольких этапов создания изображения, мне они напоминают процесс создания моделей в Blender или что-то подобное:
1. запустить и обработать **Вершинный шейдер** для каждой описанной вершины
2. выполнить **Фрагментарный шейдер** для каждого пикселя на экране\окне\изображении
3. раскрасить необходимые пиксели

### 1 - Вершинный буфер
Зададим форму нашего объекта. По умолчанию единицей графического режима является треугольник. Однако Vulkan позволяет использовать и иные формы через задание иной `PrimitiveTopology`, однако это сложная тема требующая большего раскрытия. Но возможно она будет описана, хоть и позже
Чтож, создаём свою структуру для хранения вершин (вершины тут нормированы и имеют значения от -1,0 до 1,0)
```rust
use vulkano::buffer::BufferContents;
use vulkano::pipeline::graphics::vertex_input::Vertex;

#[derive(BufferContents, Vertex)]
#[repr(C)]
struct MyVertex {
    #[format(R32G32_SFLOAT)]
    position: [f32; 2],
}
let vertex1 = MyVertex { position: [-0.5, -0.5] };
let vertex2 = MyVertex { position: [ 0.0,  0.5] };
let vertex3 = MyVertex { position: [ 0.5, -0.25] };
```
Далее нам необходим буфер вершин, где мы положим наши вершины:
```rust
let vertex_buffer = Buffer::from_iter(
    memory_allocator.clone(),
    BufferCreateInfo {
        usage: BufferUsage::VERTEX_BUFFER,
        ..Default::default()
    },
    AllocationCreateInfo {
        memory_type_filter: MemoryTypeFilter::PREFER_DEVICE
            | MemoryTypeFilter::HOST_SEQUENTIAL_WRITE,
        ..Default::default()
    },
    vec![vertex1, vertex2, vertex3],
)
.unwrap();
```
Примечание: `VERTEX_BUFFER` - тут это хоть и явный тип вершинного буфера, однако он ничем не отличается от предыдущих типов буферов, с которыми мы работали. Стоит воспринимать это как метку "хей, тут будут вершины"

### 2 - Вершинный шейдер
Далее, для каждой вершины из буфера выше, графический профессор будет вызывать вершинный шейдер
```c
#version 460
layout(location = 0) in vec2 position; 

void main() { 
	gl_Position = vec4(position, 0.0, 1.0); 
}
```
Этот шейдер берёт значения вершины и помещает их в "волшебный" gl-овский 4-х мерный вектор.
### 3 - Фрагментарный шейдер
Тут графический процессор смотрит на то какие пиксели находится внутри, описанного выше, треугольника. 
![[Pasted image 20241116215610.png]]
А вот и код самого шейдера:
```c
#version 460

layout(location = 0) out vec4 f_color;

void main() {
    f_color = vec4(1.0, 0.0, 0.0, 1.0);
}
```
### 4 - Рендерный проход (render pass)
Простыми словами тут и происходит магия рендера. Поток данных определённого формата "впитывает" в себя виртуальное изображение (в нашем случае треугольника)
```rust
let render_pass = vulkano::single_pass_renderpass!(
    device.clone(),
    attachments: {
        color: {
            format: Format::R8G8B8A8_UNORM,
            samples: 1,
            load_op: Clear,
            store_op: Store,
        },
    },
    pass: {
        color: [color],
        depth_stencil: {},
    },
)
.unwrap();
```
Проход рендеринга состоит из **приложений** и **проходов**. Здесь мы объявляем одно приложение с именем `color` (имя произвольное) и один проход, который будет использовать `color` в качестве единственного результата.
Строка `load_op: Clear` указывает на то, что мы хотим, чтобы графический процессор _очищал_ изображение при входе в этап рендеринга (заполнял его одним цветом), а `store_op: Store` указывает на то, что мы хотим, чтобы графический процессор фактически сохранял результаты выполнения наших команд отрисовки в изображении.
**Примечание**: можно создавать временные изображения, содержимое которых актуально только во время рендеринга. В этом случае оптимально использовать `store_op: DontCare` вместо `store_op: Store`.
### 5 - Ввод прохода рендера
Проход рендеринга описывает только формат и способ загрузки и хранения изображения, на котором мы будем рисовать. Этого достаточно для инициализации всех необходимых нам объектов.
Но прежде чем мы сможем рисовать, нам нужно указать фактический список вложений. Это делается путём создания _буфера кадра_.
Создание кадрового буфера обычно выполняется как часть процесса рендеринга. Неплохая идея — сохранять объекты кадрового буфера активными между кадрами, но создание и уничтожение нескольких объектов кадрового буфера в течение нескольких кадров не повлияет на производительность.
```rust
use vulkano::render_pass::{Framebuffer, FramebufferCreateInfo};

let view = ImageView::new_default(image.clone()).unwrap();
let framebuffer = Framebuffer::new(
    render_pass.clone(),
    FramebufferCreateInfo {
        attachments: vec![view],
        ..Default::default()
    },
)
.unwrap();
```
Наконец мы можем нарисовать наш треугольник на изображении.
Для этого вызываем функцию `begin_render_pass` в конструкторе командного буфера. Она принимает итератор `Vec` с значениями цвета для элемента, очевидно, что у нас элемент один, а значит и в `Vec` у нас один элемент.
```rust
use vulkano::command_buffer::{
    RenderPassBeginInfo, SubpassBeginInfo, SubpassContents, SubpassEndInfo,
};

let mut builder = AutoCommandBufferBuilder::primary(
    &command_buffer_allocator,
    queue.queue_family_index(),
    CommandBufferUsage::OneTimeSubmit,
)
.unwrap();

builder
    .begin_render_pass(
        RenderPassBeginInfo {
            clear_values: vec![Some([0.0, 0.0, 1.0, 1.0].into())],
            ..RenderPassBeginInfo::framebuffer(framebuffer.clone())
        },
        SubpassBeginInfo {
            contents: SubpassContents::Inline,
            ..Default::default()
        },
    )
    .unwrap()
    .end_render_pass(SubpassEndInfo::default())
    .unwrap();
```
Перечисляемый тип, передаваемый в качестве второго параметра, описывает, будем ли мы напрямую вызывать команды отрисовки или вместо этого использовать вторичные командные буферы. Вторичные командные буферы — более сложная тема. Поскольку мы используем только прямые команды, мы оставим его как `::Inline` 